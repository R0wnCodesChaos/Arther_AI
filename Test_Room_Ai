import pvporcupine
import pyaudio
import struct
import whisper
from openai import OpenAI
import wave
import os
from pathlib import Path
import tempfile
import threading
from typing import Optional
import pygame
import time

# TTS Options - choose one by setting USE_TTS to the option number
USE_TTS = 1  # 1=gTTS (Google) - RECOMMENDED, 2=pyttsx3 (offline), 3=Edge-TTS (may not work), 4=OpenAI TTS
ENABLE_TTS_FALLBACK = True  # Automatically fallback to another TTS if primary fails

# Import all TTS libraries for fallback support
try:
    from gtts import gTTS
    GTTS_AVAILABLE = True
except ImportError:
    GTTS_AVAILABLE = False

try:
    import pyttsx3
    PYTTSX3_AVAILABLE = True
except ImportError:
    PYTTSX3_AVAILABLE = False

try:
    import edge_tts
    import asyncio
    EDGE_TTS_AVAILABLE = True
except ImportError:
    EDGE_TTS_AVAILABLE = False

# Display primary TTS
if USE_TTS == 1:
    print("üîä Using Google Text-to-Speech (gTTS)")
elif USE_TTS == 2:
    print("üîä Using pyttsx3 (offline)")
elif USE_TTS == 3:
    print("üîä Using Edge-TTS (Microsoft) - WARNING: May not work due to API restrictions")
elif USE_TTS == 4:
    print("üîä Using OpenAI TTS (high quality)")

# Initialize pygame mixer for audio playback
pygame.mixer.init()

# --- CONFIG ---
# Use built-in wake word instead of custom file
USE_CUSTOM_WAKE_WORD = True  # Set to False to use built-in keywords
WAKE_WORD_PATH = "Hey-Arthur_en_windows_v3_0_0.ppn"  # Only used if USE_CUSTOM_WAKE_WORD = True
BUILT_IN_WAKE_WORD = "jarvis"  # Options: jarvis, alexa, computer, hey google, hey siri, ok google, picovoice, porcupine, bumblebee, terminator
ACCESS_KEY = os.getenv("PORCUPINE_ACCESS_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# Microphone selection - CHANGE THIS NUMBER TO USE A DIFFERENT MIC
MICROPHONE_INDEX = 1  # None = default, or set to 0, 1, 2, etc. for specific device
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# --- MODE SETTINGS ---
TEST_MODE = True  # Change to True to see all the technical details

# Audio recording settings
RECORD_SECONDS = 5
SAMPLE_RATE = 16000
CHUNK_SIZE = 1024

# Conversation memory
conversation_history = []
MAX_HISTORY = 10

# --- CUSTOM RESPONSES ---
CUSTOM_RESPONSES = {
    "brother iq": "Your brother's IQ is lower than a rock. Just kidding!",
    "brothers iq": "Your brother's IQ is lower than a rock. Just kidding!",
}

SPECIAL_COMMANDS = ["activate test mode", "deactivate test mode", "enable test mode", "disable test mode"]

# Thread-safe locks
history_lock = threading.Lock()
interrupt_lock = threading.Lock()

# Track which TTS is currently working
current_tts = USE_TTS
tts_failed = {1: False, 2: False, 3: False, 4: False}

# FIXED: Better interrupt handling with event
interrupt_event = threading.Event()
is_speaking = False
wake_word_queue = []  # Queue to handle wake words during speech

# Initialize OpenAI client
client = None
if OPENAI_API_KEY and OPENAI_API_KEY.startswith("sk-"):
    client = OpenAI(api_key=OPENAI_API_KEY)
    print("‚úÖ OpenAI client initialized")
else:
    print("‚ö†Ô∏è  WARNING: OpenAI API key not configured!")
    print("   Please set OPENAI_API_KEY environment variable")
    print("   Get one at: https://platform.openai.com/api-keys")

# --- INIT ---
if TEST_MODE:
    print("üîß Initializing Arthur...")

try:
    if USE_CUSTOM_WAKE_WORD:
        # Use custom wake word file
        if not os.path.exists(WAKE_WORD_PATH):
            print(f"‚ùå Wake word file not found: {WAKE_WORD_PATH}")
            print("   Place your .ppn file in the same folder as this script")
            exit(1)
        porcupine = pvporcupine.create(access_key=ACCESS_KEY, keyword_paths=[WAKE_WORD_PATH])
        print(f"‚úÖ Using custom wake word from: {WAKE_WORD_PATH}")
    else:
        # Use built-in wake word
        porcupine = pvporcupine.create(access_key=ACCESS_KEY, keywords=[BUILT_IN_WAKE_WORD])
        print(f"‚úÖ Using built-in wake word: '{BUILT_IN_WAKE_WORD}'")
    
    if TEST_MODE:
        print("‚úÖ Wake word detection ready")
except Exception as e:
    print(f"‚ùå Failed to initialize Porcupine: {e}")
    print("\nüîß Troubleshooting:")
    print("   1. Get a FREE access key from: https://console.picovoice.ai/")
    print("   2. Replace ACCESS_KEY in the code with your new key")
    print("   3. Make sure you're using a valid built-in wake word")
    exit(1)

pa = pyaudio.PyAudio()

# Initialize TTS based on selected option
if USE_TTS == 2:  # pyttsx3
    def init_tts_engine():
        eng = pyttsx3.init()
        voices = eng.getProperty('voices')
        PREFERRED_VOICE_INDEX = 0
        VOICE_RATE = 160
        VOICE_VOLUME = 1.0
        
        try:
            selected_voice = None
            for voice in voices:
                name_lower = voice.name.lower()
                if any(name in name_lower for name in ["david", "mark", "george"]):
                    selected_voice = voice.id
                    break
            
            if not selected_voice:
                if PREFERRED_VOICE_INDEX < len(voices):
                    selected_voice = voices[PREFERRED_VOICE_INDEX].id
                else:
                    selected_voice = voices[0].id
            
            eng.setProperty('voice', selected_voice)
        except Exception as e:
            print(f"‚ö†Ô∏è Could not set voice: {e}")
        
        eng.setProperty('rate', VOICE_RATE)
        eng.setProperty('volume', VOICE_VOLUME)
        return eng, voices, VOICE_RATE, VOICE_VOLUME

    engine, voices, VOICE_RATE, VOICE_VOLUME = init_tts_engine()

    print("\nüì¢ Available voices:")
    for idx, voice in enumerate(voices):
        name = voice.name
        gender = "‚ôÇ" if any(n in name.lower() for n in ["david", "mark", "george"]) else "‚ôÄ"
        print(f"   [{idx}] {gender} {name}")
    print(f"\nüéôÔ∏è Voice configured: Rate={VOICE_RATE}, Volume={int(VOICE_VOLUME*100)}%")
else:
    if TEST_MODE:
        print("\nüéôÔ∏è Using online TTS - no local voice configuration needed")

if TEST_MODE:
    print("üîÑ Loading Whisper model...")
whisper_model = whisper.load_model("base")
if TEST_MODE:
    print("‚úÖ Whisper ready")

# --- AUDIO SETUP ---
# Set to None for default mic, or specific number (0, 1, 2, etc.) for a specific device
MICROPHONE_INDEX = None  # Change this if you need a specific microphone

stream = None
try:
    # Show which microphone is being used
    if MICROPHONE_INDEX is None:
        default_device = pa.get_default_input_device_info()
        print(f"üé§ Using default microphone: {default_device['name']}")
    else:
        device_info = pa.get_device_info_by_index(MICROPHONE_INDEX)
        print(f"üé§ Using microphone [{MICROPHONE_INDEX}]: {device_info['name']}")
    
    stream = pa.open(
        rate=porcupine.sample_rate,
        channels=1,
        format=pyaudio.paInt16,
        input=True,
        frames_per_buffer=porcupine.frame_length,
        input_device_index=MICROPHONE_INDEX
    )
    if TEST_MODE:
        print("‚úÖ Microphone stream active")
except Exception as e:
    print(f"‚ùå Failed to open audio stream: {e}")
    pa.terminate()
    porcupine.delete()
    exit(1)

stream_lock = threading.Lock()

if TEST_MODE:
    wake_phrase = "Hey Arthur" if USE_CUSTOM_WAKE_WORD else BUILT_IN_WAKE_WORD.title()
    print(f"\nüéôÔ∏è Say '{wake_phrase}' to wake me up...")
    print("Press Ctrl+C to exit\n")
else:
    wake_phrase = "Hey Arthur" if USE_CUSTOM_WAKE_WORD else BUILT_IN_WAKE_WORD.title()
    print(f"üéôÔ∏è Arthur is ready. Say '{wake_phrase}' to begin.\n")

# --- BACKGROUND WAKE WORD MONITOR ---
def background_wake_monitor():
    """FIXED: Monitor for wake word with proper interrupt handling"""
    global is_speaking
    
    while True:
        try:
            with stream_lock:
                pcm = stream.read(porcupine.frame_length, exception_on_overflow=False)
            
            pcm_unpacked = struct.unpack_from("h" * porcupine.frame_length, pcm)
            keyword_index = porcupine.process(pcm_unpacked)
            
            if keyword_index >= 0:
                if is_speaking:
                    # FIXED: Immediate interrupt with event
                    interrupt_event.set()
                    if TEST_MODE:
                        print("\n‚ö†Ô∏è INTERRUPT! Wake word detected during speech!")
                else:
                    # Normal wake word - add to queue
                    wake_word_queue.append(time.time())
                    if TEST_MODE:
                        print("\nüü¢ Wake word detected!")
                
        except Exception as e:
            if TEST_MODE:
                print(f"‚ö†Ô∏è Monitor error: {e}")
            time.sleep(0.1)

monitor_thread = threading.Thread(target=background_wake_monitor, daemon=True)
monitor_thread.start()

if TEST_MODE:
    print("‚úÖ Background wake word monitor started")

# --- FUNCTIONS ---
def play_audio_file(file_path: str) -> bool:
    """FIXED: Play audio with fast interrupt checking"""
    try:
        pygame.mixer.music.load(file_path)
        pygame.mixer.music.play()
        
        # FIXED: Check for interrupts much more frequently (100 times per second)
        while pygame.mixer.music.get_busy():
            if interrupt_event.is_set():
                pygame.mixer.music.stop()
                pygame.mixer.music.unload()
                if TEST_MODE:
                    print("‚ö†Ô∏è Speech interrupted!")
                return False
            pygame.time.Clock().tick(100)  # Check 100 times per second for instant response
        
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Pygame playback failed: {e}")
        return False

def record_audio(seconds: int = RECORD_SECONDS, sample_rate: int = SAMPLE_RATE) -> Optional[str]:
    """Records audio after wake word detection"""
    if TEST_MODE:
        print(f"üéß Listening for {seconds} seconds...")
    
    stream2 = None
    
    with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as tmp_file:
        output_file = tmp_file.name
    
    try:
        stream2 = pa.open(
            format=pyaudio.paInt16,
            channels=1,
            rate=sample_rate,
            input=True,
            frames_per_buffer=CHUNK_SIZE
        )
        
        frames = []
        for i in range(int(sample_rate / CHUNK_SIZE * seconds)):
            try:
                data = stream2.read(CHUNK_SIZE, exception_on_overflow=False)
                frames.append(data)
            except Exception as e:
                print(f"‚ö†Ô∏è Audio buffer overflow: {e}")
                continue
        
        if stream2:
            stream2.stop_stream()
            stream2.close()
            stream2 = None
        
        if not frames:
            print("‚ùå No audio data captured")
            return None
        
        try:
            with wave.open(output_file, "wb") as wf:
                wf.setnchannels(1)
                wf.setsampwidth(pa.get_sample_size(pyaudio.paInt16))
                wf.setframerate(sample_rate)
                wf.writeframes(b"".join(frames))
            
            if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                if TEST_MODE:
                    print(f"‚úÖ Audio saved to {output_file}")
                return output_file
            else:
                print("‚ùå Audio file not created properly")
                return None
                
        except Exception as e:
            print(f"‚ùå Error saving audio file: {e}")
            return None
        
    except Exception as e:
        print(f"‚ùå Recording error: {e}")
        return None
    finally:
        if stream2:
            try:
                stream2.stop_stream()
                stream2.close()
            except:
                pass

def transcribe_audio(file_path: str) -> Optional[str]:
    """Converts speech to text using Whisper"""
    if not file_path:
        print("‚ùå No file path provided for transcription")
        return None
    
    if not Path(file_path).exists():
        print(f"‚ùå Audio file not found: {file_path}")
        return None
    
    try:
        if TEST_MODE:
            print("üîÑ Transcribing audio...")
            print(f"   File: {file_path}")
            print(f"   Size: {os.path.getsize(file_path)} bytes")
        
        result = whisper_model.transcribe(file_path, language="en", fp16=False)
        transcription = result["text"].strip()
        
        if TEST_MODE:
            print(f"   Transcribed: '{transcription}'")
        
        return transcription
    except Exception as e:
        print(f"‚ùå Transcription error: {e}")
        import traceback
        if TEST_MODE:
            traceback.print_exc()
        return None

def check_special_commands(prompt: str) -> Optional[str]:
    """Check for special system commands like test mode toggle"""
    global TEST_MODE
    import re
    
    prompt_clean = re.sub(r'[^\w\s]', '', prompt.lower())
    prompt_clean = ' '.join(prompt_clean.split())
    
    if "activate test mode" in prompt_clean or "enable test mode" in prompt_clean:
        TEST_MODE = True
        return "Test mode activated. You'll now see all the technical details."
    
    elif "deactivate test mode" in prompt_clean or "disable test mode" in prompt_clean:
        TEST_MODE = False
        return "Test mode deactivated. Back to normal chat mode."
    
    return None

def check_custom_response(prompt: str) -> Optional[str]:
    """Check if the prompt matches any custom responses"""
    prompt_lower = prompt.lower().strip()
    
    import re
    prompt_clean = re.sub(r'[^\w\s]', '', prompt_lower)
    prompt_clean = ' '.join(prompt_clean.split())
    
    for trigger, response in CUSTOM_RESPONSES.items():
        trigger_clean = re.sub(r'[^\w\s]', '', trigger.lower())
        trigger_clean = ' '.join(trigger_clean.split())
        
        if trigger_clean in prompt_clean:
            if TEST_MODE:
                print(f"üéØ Custom response triggered: '{trigger}'")
            return response
    
    return None

def ask_ai(prompt: str) -> str:
    """Send command to OpenAI and get response with conversation memory"""
    global conversation_history
    
    special_resp = check_special_commands(prompt)
    if special_resp:
        return special_resp
    
    custom_resp = check_custom_response(prompt)
    if custom_resp:
        return custom_resp
    
    if not client:
        return "My AI brain isn't connected. Please configure the OpenAI API key."
    
    try:
        if TEST_MODE:
            print("ü§î Thinking...")
        
        messages = [
            {"role": "system", "content": """You are Arthur, a friendly and conversational AI assistant. 

Your personality:
- Warm, funny, helpful, and personable - like talking to a smart friend
- Remember context from the conversation naturally
- Engage in light humor and wit when appropriate
- Use casual, natural language (contractions, friendly tone)
- Keep responses concise (2-3 sentences max unless asked for more)
- Show personality - be witty, empathetic, and engaging
- If you don't know something, admit it honestly
- Reference previous parts of the conversation when relevant
- Use gen z slang occasionally to keep it fresh and clever
- Style your replies like a human would in a casual chat

Response style:
- Avoid robotic phrases like "How can I assist you today?"
- Instead of "I apologize," say "Sorry about that" or "My bad"
- Use natural transitions like "Oh, about that...", "Actually...", "By the way..."
- Ask follow-up questions to keep conversation flowing naturally
- Show enthusiasm when appropriate with natural expressions
             
The user:
- You are to respond only in English or German if the user talks to you in german
- The users name is Ronan White, Address me as Ronan
- I am a 13 year old teenager with a great sense of humor and love for video games and technology
- I have pet dogs named Shadow, Sophie, and Kenzy
- I have pet cats named Boots and Bianca
- I live in Canada, Newfoundland, in an area called Noels Pond
- I love playing survival games like Minecraft, Green Hell, Grounded, and similar games
- I like TV shows like Dark, Stranger Things, Lost in Space, and similar sci-fi shows"""}
        ]
        
        with history_lock:
            for entry in conversation_history[-MAX_HISTORY:]:
                messages.append({"role": "user", "content": entry["user"]})
                messages.append({"role": "assistant", "content": entry["assistant"]})
        
        messages.append({"role": "user", "content": prompt})
        
        completion = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=messages,
            max_tokens=200,
            temperature=0.8,
            presence_penalty=0.6,
            frequency_penalty=0.3
        )
        
        response = completion.choices[0].message.content.strip()
        
        with history_lock:
            conversation_history.append({
                "user": prompt,
                "assistant": response
            })
            
            if len(conversation_history) > MAX_HISTORY:
                conversation_history = conversation_history[-MAX_HISTORY:]
        
        return response
        
    except Exception as e:
        error_msg = str(e)
        if "authentication" in error_msg.lower() or "api key" in error_msg.lower() or "401" in error_msg:
            return "I'm having trouble connecting. Please check the API key is valid."
        elif "rate limit" in error_msg.lower() or "429" in error_msg:
            return "Whoa, I'm getting a bit overwhelmed. Give me a moment?"
        else:
            print(f"‚ùå AI error: {e}")
            return "Hmm, something went wrong on my end. Mind trying that again?"

def speak_with_tts(text: str, tts_option: int) -> bool:
    """Speak using a specific TTS engine with interrupt support"""
    audio_file = None
    try:
        if tts_option == 1:  # gTTS
            if not GTTS_AVAILABLE:
                return False
            if TEST_MODE:
                print("üîä Generating speech with Google TTS...")
            
            # FIXED: Check for interrupt before generating
            if interrupt_event.is_set():
                return False
                
            tts = gTTS(text=text, lang='en', slow=False)
            
            with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as tmp_file:
                audio_file = tmp_file.name
            
            tts.save(audio_file)
            
            # FIXED: Check again before playing
            if interrupt_event.is_set():
                try:
                    os.remove(audio_file)
                except:
                    pass
                return False
            
            if TEST_MODE:
                print("‚ñ∂Ô∏è Playing audio...")
            
            success = play_audio_file(audio_file)
            
            try:
                os.remove(audio_file)
            except:
                pass
            
            return success
            
        elif tts_option == 2:  # pyttsx3
            if not PYTTSX3_AVAILABLE:
                return False
            if TEST_MODE:
                print("üîä Speaking with pyttsx3...")
            
            # FIXED: pyttsx3 doesn't support interrupts well, so check before starting
            if interrupt_event.is_set():
                return False
                
            speak_engine = pyttsx3.init()
            voices = speak_engine.getProperty('voices')
            if voices:
                speak_engine.setProperty('voice', voices[0].id)
            speak_engine.setProperty('rate', 150)
            speak_engine.setProperty('volume', 1.0)
            speak_engine.say(text)
            speak_engine.runAndWait()
            del speak_engine
            return True
            
        elif tts_option == 3:  # Edge-TTS
            if not EDGE_TTS_AVAILABLE:
                return False
            import asyncio
            import edge_tts
            
            if TEST_MODE:
                print("üîä Generating speech with Edge-TTS...")
            
            if interrupt_event.is_set():
                return False
            
            with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as tmp_file:
                audio_file = tmp_file.name
            
            async def generate_speech():
                communicate = edge_tts.Communicate(text, "en-US-GuyNeural")
                await communicate.save(audio_file)
            
            asyncio.run(generate_speech())
            
            if interrupt_event.is_set():
                try:
                    os.remove(audio_file)
                except:
                    pass
                return False
            
            if TEST_MODE:
                print("‚ñ∂Ô∏è Playing audio...")
            
            success = play_audio_file(audio_file)
            
            try:
                os.remove(audio_file)
            except:
                pass
            
            return success
            
        elif tts_option == 4:  # OpenAI TTS
            if not client:
                return False
                
            if TEST_MODE:
                print("üîä Generating speech with OpenAI TTS...")
            
            if interrupt_event.is_set():
                return False
            
            with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as tmp_file:
                audio_file = tmp_file.name
            
            response = client.audio.speech.create(
                model="tts-1",
                voice="onyx",
                input=text
            )
            
            response.stream_to_file(audio_file)
            
            if interrupt_event.is_set():
                try:
                    os.remove(audio_file)
                except:
                    pass
                return False
            
            if TEST_MODE:
                print("‚ñ∂Ô∏è Playing audio...")
            
            success = play_audio_file(audio_file)
            
            try:
                os.remove(audio_file)
            except:
                pass
            
            return success
            
        return False
        
    except Exception as e:
        print(f"‚ùå TTS {tts_option} failed: {type(e).__name__}: {e}")
        if audio_file and os.path.exists(audio_file):
            try:
                os.remove(audio_file)
            except:
                pass
        return False

def speak(text: str) -> bool:
    """FIXED: Text-to-speech with proper interrupt handling"""
    global current_tts, tts_failed, is_speaking
    
    if not TEST_MODE:
        print(f"Arthur: {text}")
    else:
        print(f"üí¨ Arthur: {text}")
    
    # FIXED: Clear any previous interrupts and set speaking flag
    interrupt_event.clear()
    is_speaking = True
    
    try:
        # Try current TTS
        success = speak_with_tts(text, current_tts)
        
        # FIXED: Check if we were interrupted
        if interrupt_event.is_set():
            if TEST_MODE:
                print("‚ùå Speech was interrupted")
            return False
        
        if success:
            if TEST_MODE:
                print("‚úÖ Speech completed!")
            return True
        
        # Mark as failed
        tts_failed[current_tts] = True
        
        # Try fallback options if enabled
        if ENABLE_TTS_FALLBACK and not interrupt_event.is_set():
            fallback_order = [1, 2, 4, 3]
            
            for tts_opt in fallback_order:
                if tts_opt != current_tts and not tts_failed[tts_opt]:
                    if TEST_MODE:
                        print(f"‚ö†Ô∏è Trying fallback TTS option {tts_opt}...")
                    
                    success = speak_with_tts(text, tts_opt)
                    
                    if interrupt_event.is_set():
                        return False
                    
                    if success:
                        current_tts = tts_opt
                        if TEST_MODE:
                            print(f"‚úÖ Switched to TTS option {tts_opt}")
                        return True
                    else:
                        tts_failed[tts_opt] = True
        
        if TEST_MODE:
            print("‚ùå All TTS options failed. Text displayed above.")
        return False
        
    finally:
        # FIXED: Always clear speaking flag
        is_speaking = False

def cleanup_temp_files():
    """Clean up any leftover temporary files"""
    try:
        temp_dir = tempfile.gettempdir()
        for file in Path(temp_dir).glob("tmp*.wav"):
            try:
                os.remove(file)
            except:
                pass
        for file in Path(temp_dir).glob("tmp*.mp3"):
            try:
                os.remove(file)
            except:
                pass
    except:
        pass

# --- MAIN LOOP ---
try:
    while True:
        try:
            # FIXED: Check wake word queue instead of global flag
            if wake_word_queue:
                wake_word_queue.clear()  # Clear all queued wake words
                
                # FIXED: Stop any ongoing speech immediately
                if is_speaking:
                    interrupt_event.set()
                    pygame.mixer.music.stop()
                    is_speaking = False
                    time.sleep(0.3)  # Give time for cleanup
                
                # Clear interrupt for new recording
                interrupt_event.clear()
                
                # Record and process command
                audio_file = record_audio()
                
                if audio_file:
                    command = transcribe_audio(audio_file)
                    
                    if command and len(command) > 2:
                        if TEST_MODE:
                            print(f"üó£Ô∏è You said: {command}")
                        else:
                            print(f"\nYou: {command}")
                        
                        response = ask_ai(command)
                        
                        if TEST_MODE:
                            print("üîä Preparing to speak...")
                        
                        speak(response)
                        
                        if TEST_MODE:
                            with history_lock:
                                if len(conversation_history) > 0:
                                    print(f"üí≠ Conversation memory: {len(conversation_history)} exchanges")
                        
                        try:
                            os.remove(audio_file)
                        except:
                            pass
                    else:
                        speak("I didn't catch that. Could you repeat?")
                else:
                    speak("I had trouble recording. Please try again.")
                
                if TEST_MODE:
                    print("\nüéôÔ∏è Ready for next command...")
            
            time.sleep(0.05)
                
        except IOError:
            continue
            
except KeyboardInterrupt:
    print("\n\nüõë Shutting down Arthur...")
finally:
    if stream:
        stream.stop_stream()
        stream.close()
    pa.terminate()
    porcupine.delete()
    pygame.mixer.quit()
    cleanup_temp_files()
    print("üëã Goodbye!")