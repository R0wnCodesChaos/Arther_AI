import pvporcupine
import pyaudio
import struct
import whisper
from openai import OpenAI
import wave
import os
from pathlib import Path
import tempfile
import threading
from typing import Optional
import pygame  # Better audio playback for Windows

# TTS Options - choose one by setting USE_TTS to the option number
USE_TTS = 1  # 1=gTTS (Google) - RECOMMENDED, 2=pyttsx3 (offline), 3=Edge-TTS (may not work), 4=OpenAI TTS
ENABLE_TTS_FALLBACK = True  # Automatically fallback to another TTS if primary fails

# Import all TTS libraries for fallback support
try:
    from gtts import gTTS
    GTTS_AVAILABLE = True
except ImportError:
    GTTS_AVAILABLE = False

try:
    import pyttsx3
    PYTTSX3_AVAILABLE = True
except ImportError:
    PYTTSX3_AVAILABLE = False

try:
    import edge_tts
    import asyncio
    EDGE_TTS_AVAILABLE = True
except ImportError:
    EDGE_TTS_AVAILABLE = False

# Display primary TTS
if USE_TTS == 1:
    print("üîä Using Google Text-to-Speech (gTTS)")
elif USE_TTS == 2:
    print("üîä Using pyttsx3 (offline)")
elif USE_TTS == 3:
    print("üîä Using Edge-TTS (Microsoft) - WARNING: May not work due to API restrictions")
elif USE_TTS == 4:
    print("üîä Using OpenAI TTS (high quality)")

# Initialize pygame mixer for audio playback
pygame.mixer.init()

# --- CONFIG ---
WAKE_WORD_PATH = "Hey-Arthur_en_windows_v3_0_0.ppn"
ACCESS_KEY = os.getenv("PORCUPINE_ACCESS_KEY")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

# --- MODE SETTINGS ---
# Set to True for detailed debug info, False for clean chat experience
TEST_MODE = False  # Change to True to see all the technical details

# Audio recording settings
RECORD_SECONDS = 5
SAMPLE_RATE = 16000
CHUNK_SIZE = 1024

# Conversation memory
conversation_history = []
MAX_HISTORY = 10

# --- CUSTOM RESPONSES ---
# Add your own trigger phrases and responses here
# Format: "trigger phrase": "response"
# Keep triggers simple without punctuation for best matching
CUSTOM_RESPONSES = {
    "brother iq": "Your brother's IQ is lower than a rock. Just kidding!",
    "brothers iq": "Your brother's IQ is lower than a rock. Just kidding!",
    # Add more custom responses below:
    # "trigger": "response",
}

# Special commands that don't need custom responses (handled separately)
SPECIAL_COMMANDS = ["activate test mode", "deactivate test mode", "enable test mode", "disable test mode"]

# Thread-safe lock for conversation history
history_lock = threading.Lock()

# Track which TTS is currently working
current_tts = USE_TTS
tts_failed = {1: False, 2: False, 3: False, 4: False}

# Flag to interrupt speech
interrupt_speech = False
is_speaking = False
wake_word_detected = False

# Initialize OpenAI client
client = None
if OPENAI_API_KEY and OPENAI_API_KEY.startswith("sk-"):
    client = OpenAI(api_key=OPENAI_API_KEY)
    print("‚úÖ OpenAI client initialized")
else:
    print("‚ö†Ô∏è  WARNING: OpenAI API key not configured!")
    print("   Please set OPENAI_API_KEY environment variable")
    print("   Get one at: https://platform.openai.com/api-keys")

# --- INIT ---
if TEST_MODE:
    print("üîß Initializing Arthur...")

try:
    porcupine = pvporcupine.create(access_key=ACCESS_KEY, keyword_paths=[WAKE_WORD_PATH])
    if TEST_MODE:
        print("‚úÖ Wake word detection ready")
except Exception as e:
    print(f"‚ùå Failed to initialize Porcupine: {e}")
    exit(1)

pa = pyaudio.PyAudio()

# Initialize TTS based on selected option
if USE_TTS == 2:  # pyttsx3
    def init_tts_engine():
        """Initialize or reinitialize the TTS engine"""
        eng = pyttsx3.init()
        
        voices = eng.getProperty('voices')
        
        PREFERRED_VOICE_INDEX = 0
        VOICE_RATE = 160
        VOICE_VOLUME = 1.0
        
        try:
            selected_voice = None
            for voice in voices:
                name_lower = voice.name.lower()
                if any(name in name_lower for name in ["david", "mark", "george"]):
                    selected_voice = voice.id
                    break
            
            if not selected_voice:
                if PREFERRED_VOICE_INDEX < len(voices):
                    selected_voice = voices[PREFERRED_VOICE_INDEX].id
                else:
                    selected_voice = voices[0].id
            
            eng.setProperty('voice', selected_voice)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Could not set voice: {e}")
        
        eng.setProperty('rate', VOICE_RATE)
        eng.setProperty('volume', VOICE_VOLUME)
        
        return eng, voices, VOICE_RATE, VOICE_VOLUME

    engine, voices, VOICE_RATE, VOICE_VOLUME = init_tts_engine()

    # Configure TTS voice for Arthur
    print("\nüì¢ Available voices:")
    for idx, voice in enumerate(voices):
        name = voice.name
        gender = "‚ôÇ" if any(n in name.lower() for n in ["david", "mark", "george"]) else "‚ôÄ"
        print(f"   [{idx}] {gender} {name}")

    print(f"\nüéôÔ∏è Voice configured: Rate={VOICE_RATE}, Volume={int(VOICE_VOLUME*100)}%")
else:
    if TEST_MODE:
        print("\nüéôÔ∏è Using online TTS - no local voice configuration needed")

if TEST_MODE:
    print("üîÑ Loading Whisper model...")
whisper_model = whisper.load_model("base")
if TEST_MODE:
    print("‚úÖ Whisper ready")

# --- AUDIO SETUP ---
stream = None
try:
    stream = pa.open(
        rate=porcupine.sample_rate,
        channels=1,
        format=pyaudio.paInt16,
        input=True,
        frames_per_buffer=porcupine.frame_length,
        input_device_index=None
    )
    if TEST_MODE:
        print("‚úÖ Microphone stream active")
except Exception as e:
    print(f"‚ùå Failed to open audio stream: {e}")
    pa.terminate()
    porcupine.delete()
    exit(1)

# Create a lock for the audio stream
stream_lock = threading.Lock()

if TEST_MODE:
    print("\nüéôÔ∏è Say 'Hey Arthur' to wake me up...")
    print("Press Ctrl+C to exit\n")
else:
    print("üéôÔ∏è Arthur is ready. Say 'Hey Arthur' to begin.\n")

# --- BACKGROUND WAKE WORD MONITOR ---
def background_wake_monitor():
    """Monitor for wake word in background, even during speech"""
    global wake_word_detected, interrupt_speech, is_speaking
    
    while True:
        try:
            with stream_lock:
                pcm = stream.read(porcupine.frame_length, exception_on_overflow=False)
            
            pcm_unpacked = struct.unpack_from("h" * porcupine.frame_length, pcm)
            keyword_index = porcupine.process(pcm_unpacked)
            
            if keyword_index >= 0:
                if is_speaking:
                    # Interrupt current speech
                    interrupt_speech = True
                    if TEST_MODE:
                        print("\n‚ö†Ô∏è Interrupting - wake word detected during speech!")
                
                wake_word_detected = True
                
        except Exception as e:
            if TEST_MODE:
                print(f"‚ö†Ô∏è Monitor error: {e}")
            import time
            time.sleep(0.1)

# Start background monitor
monitor_thread = threading.Thread(target=background_wake_monitor, daemon=True)
monitor_thread.start()

if TEST_MODE:
    print("‚úÖ Background wake word monitor started")

# --- FUNCTIONS ---
def play_audio_file(file_path: str) -> bool:
    """Play audio file using pygame mixer with interrupt support"""
    global interrupt_speech
    
    try:
        pygame.mixer.music.load(file_path)
        pygame.mixer.music.play()
        
        # Wait for playback to finish, but check for interrupts frequently
        while pygame.mixer.music.get_busy():
            if interrupt_speech:
                pygame.mixer.music.stop()
                pygame.mixer.music.unload()
                if TEST_MODE:
                    print("‚ö†Ô∏è Speech stopped due to interrupt!")
                return False
            pygame.time.Clock().tick(20)  # Check 20 times per second
        
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Pygame playback failed: {e}")
        return False

def check_for_wake_word_during_speech():
    """Removed - now handled by background thread"""
    pass

def record_audio(seconds: int = RECORD_SECONDS, sample_rate: int = SAMPLE_RATE) -> Optional[str]:
    """Records audio after wake word detection"""
    if TEST_MODE:
        print(f"üéß Listening for {seconds} seconds...")
    
    stream2 = None
    
    # Use temporary file to avoid conflicts
    with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as tmp_file:
        output_file = tmp_file.name
    
    try:
        stream2 = pa.open(
            format=pyaudio.paInt16,
            channels=1,
            rate=sample_rate,
            input=True,
            frames_per_buffer=CHUNK_SIZE
        )
        
        frames = []
        for i in range(int(sample_rate / CHUNK_SIZE * seconds)):
            try:
                data = stream2.read(CHUNK_SIZE, exception_on_overflow=False)
                frames.append(data)
            except Exception as e:
                print(f"‚ö†Ô∏è Audio buffer overflow: {e}")
                continue
        
        if stream2:
            stream2.stop_stream()
            stream2.close()
            stream2 = None
        
        if not frames:
            print("‚ùå No audio data captured")
            return None
        
        try:
            with wave.open(output_file, "wb") as wf:
                wf.setnchannels(1)
                wf.setsampwidth(pa.get_sample_size(pyaudio.paInt16))
                wf.setframerate(sample_rate)
                wf.writeframes(b"".join(frames))
            
            if os.path.exists(output_file) and os.path.getsize(output_file) > 0:
                if TEST_MODE:
                    print(f"‚úÖ Audio saved to {output_file}")
                return output_file
            else:
                print("‚ùå Audio file not created properly")
                return None
                
        except Exception as e:
            print(f"‚ùå Error saving audio file: {e}")
            return None
        
    except Exception as e:
        print(f"‚ùå Recording error: {e}")
        return None
    finally:
        if stream2:
            try:
                stream2.stop_stream()
                stream2.close()
            except:
                pass

def transcribe_audio(file_path: str) -> Optional[str]:
    """Converts speech to text using Whisper"""
    if not file_path or not Path(file_path).exists():
        return None
    
    try:
        if TEST_MODE:
            print("üîÑ Transcribing audio...")
        result = whisper_model.transcribe(file_path, language="en")
        return result["text"].strip()
    except Exception as e:
        print(f"‚ùå Transcription error: {e}")
        return None

def check_special_commands(prompt: str) -> Optional[str]:
    """Check for special system commands like test mode toggle"""
    global TEST_MODE
    import re
    
    prompt_clean = re.sub(r'[^\w\s]', '', prompt.lower())
    prompt_clean = ' '.join(prompt_clean.split())
    
    if "activate test mode" in prompt_clean or "enable test mode" in prompt_clean:
        TEST_MODE = True
        return "Test mode activated. You'll now see all the technical details."
    
    elif "deactivate test mode" in prompt_clean or "disable test mode" in prompt_clean:
        TEST_MODE = False
        return "Test mode deactivated. Back to normal chat mode."
    
    return None

def check_custom_response(prompt: str) -> Optional[str]:
    """Check if the prompt matches any custom responses"""
    prompt_lower = prompt.lower().strip()
    
    # Remove ALL punctuation and extra spaces
    import re
    prompt_clean = re.sub(r'[^\w\s]', '', prompt_lower)  # Remove all punctuation
    prompt_clean = ' '.join(prompt_clean.split())  # Normalize spaces
    
    for trigger, response in CUSTOM_RESPONSES.items():
        trigger_clean = re.sub(r'[^\w\s]', '', trigger.lower())
        trigger_clean = ' '.join(trigger_clean.split())
        
        # Check if trigger phrase is in the prompt
        if trigger_clean in prompt_clean:
            if TEST_MODE:
                print(f"üéØ Custom response triggered: '{trigger}'")
            return response
    
    return None

def ask_ai(prompt: str) -> str:
    """Send command to OpenAI and get response with conversation memory"""
    global conversation_history
    
    # First check for special commands (like test mode toggle)
    special_resp = check_special_commands(prompt)
    if special_resp:
        return special_resp
    
    # Then check for custom responses
    custom_resp = check_custom_response(prompt)
    if custom_resp:
        return custom_resp
    
    if not client:
        return "My AI brain isn't connected. Please configure the OpenAI API key."
    
    try:
        if TEST_MODE:
            print("ü§î Thinking...")
        
        messages = [
            {"role": "system", "content": """You are Arthur, a friendly and conversational AI assistant. 

Your personality:
- Warm, funny, helpful, and personable - like talking to a smart friend
- Remember context from the conversation naturally and funnily
- Engage in light humor and wit when appropriate
- Use casual, natural language (contractions, friendly tone)
- wittKeep responses concise (2-3 sentences max unless asked for more)
- Show personality - be y, empathetic, and engaging when appropriate
- If you don't know something, admit it honestly
- Reference previous parts of the conversation when relevant
- Use gen z slang occasionally to keep it fresh and clever
- Style your replies like a human would in a casual chat

Response style:
- Avoid robotic phrases like "How can I assist you today?"
- Instead of "I apologize," say "Sorry about that" or "My bad"
- Use natural transitions like "Oh, about that...", "Actually...", "By the way..."
- Ask follow-up questions to keep conversation flowing naturally
- Show enthusiasm when appropriate with natural expressions
             
The user
             
- You are to respond only in English or German if the user talks to you in german
- The users name is Ronan White, Adress me as Ronan
- I am a 13 year old teenager with a great sense of humor and love for video games and technology
- I have a pet dog named Shadow
- I have a pet dog named Sophie
- I have a pet dog named Kenzy
- I have a pet cat named Boots
- I have a pet cat named Bianca
- i live in Canada, Newfoundland, in a area called noels pond
- I love playing survival games like Minecraft, Green hell, Grounded, Grounded 2, and More like those
- I like the tv shows Dark, Stranger Things, Lost in Space, and more like those"""}
        ]
        
        # Thread-safe access to conversation history
        with history_lock:
            for entry in conversation_history[-MAX_HISTORY:]:
                messages.append({"role": "user", "content": entry["user"]})
                messages.append({"role": "assistant", "content": entry["assistant"]})
        
        messages.append({"role": "user", "content": prompt})
        
        completion = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=messages,
            max_tokens=200,
            temperature=0.8,
            presence_penalty=0.6,
            frequency_penalty=0.3
        )
        
        response = completion.choices[0].message.content.strip()
        
        # Thread-safe update to conversation history
        with history_lock:
            conversation_history.append({
                "user": prompt,
                "assistant": response
            })
            
            if len(conversation_history) > MAX_HISTORY:
                conversation_history = conversation_history[-MAX_HISTORY:]
        
        return response
        
    except Exception as e:
        error_msg = str(e)
        if "authentication" in error_msg.lower() or "api key" in error_msg.lower() or "401" in error_msg:
            return "I'm having trouble connecting. Please check the API key is valid."
        elif "rate limit" in error_msg.lower() or "429" in error_msg:
            return "Whoa, I'm getting a bit overwhelmed. Give me a moment?"
        else:
            print(f"‚ùå AI error: {e}")
            return "Hmm, something went wrong on my end. Mind trying that again?"

def speak_with_tts(text: str, tts_option: int) -> bool:
    """Speak using a specific TTS engine"""
    audio_file = None
    try:
        if tts_option == 1:  # gTTS (Google Text-to-Speech)
            if not GTTS_AVAILABLE:
                return False
            if TEST_MODE:
                print("üîä Generating speech with Google TTS...")
            tts = gTTS(text=text, lang='en', slow=False)
            
            with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as tmp_file:
                audio_file = tmp_file.name
            
            tts.save(audio_file)
            if TEST_MODE:
                print("‚ñ∂Ô∏è Playing audio...")
            
            success = play_audio_file(audio_file)
            
            try:
                os.remove(audio_file)
            except:
                pass
            
            return success
            
        elif tts_option == 2:  # pyttsx3
            if not PYTTSX3_AVAILABLE:
                return False
            if TEST_MODE:
                print("üîä Speaking with pyttsx3...")
            speak_engine = pyttsx3.init()
            voices = speak_engine.getProperty('voices')
            if voices:
                speak_engine.setProperty('voice', voices[0].id)
            speak_engine.setProperty('rate', 150)
            speak_engine.setProperty('volume', 1.0)
            speak_engine.say(text)
            speak_engine.runAndWait()
            del speak_engine
            return True
            
        elif tts_option == 3:  # Edge-TTS (Microsoft)
            if not EDGE_TTS_AVAILABLE:
                return False
            import asyncio
            import edge_tts
            
            if TEST_MODE:
                print("üîä Generating speech with Edge-TTS...")
            
            with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as tmp_file:
                audio_file = tmp_file.name
            
            async def generate_speech():
                communicate = edge_tts.Communicate(text, "en-US-GuyNeural")
                await communicate.save(audio_file)
            
            asyncio.run(generate_speech())
            if TEST_MODE:
                print("‚ñ∂Ô∏è Playing audio...")
            
            success = play_audio_file(audio_file)
            
            try:
                os.remove(audio_file)
            except:
                pass
            
            return success
            
        elif tts_option == 4:  # OpenAI TTS
            if not client:
                return False
                
            if TEST_MODE:
                print("üîä Generating speech with OpenAI TTS...")
            
            with tempfile.NamedTemporaryFile(suffix=".mp3", delete=False) as tmp_file:
                audio_file = tmp_file.name
            
            response = client.audio.speech.create(
                model="tts-1",
                voice="onyx",  # Options: alloy, echo, fable, onyx, nova, shimmer
                input=text
            )
            
            response.stream_to_file(audio_file)
            if TEST_MODE:
                print("‚ñ∂Ô∏è Playing audio...")
            
            success = play_audio_file(audio_file)
            
            try:
                os.remove(audio_file)
            except:
                pass
            
            return success
            
        return False
        
    except Exception as e:
        print(f"‚ùå TTS {tts_option} failed: {type(e).__name__}: {e}")
        if audio_file and os.path.exists(audio_file):
            try:
                os.remove(audio_file)
            except:
                pass
        return False

def speak(text: str) -> bool:
    """Text-to-speech output with automatic fallback"""
    global current_tts, tts_failed, is_speaking, interrupt_speech
    
    if not TEST_MODE:
        print(f"Arthur: {text}")
    else:
        print(f"üí¨ Arthur: {text}")
    
    is_speaking = True
    
    # Try current TTS
    success = speak_with_tts(text, current_tts)
    
    is_speaking = False
    
    if success:
        if TEST_MODE:
            print("‚úÖ Speech completed!")
        return True
    
    # Mark as failed
    tts_failed[current_tts] = True
    
    # Try fallback options if enabled
    if ENABLE_TTS_FALLBACK:
        fallback_order = [1, 2, 4, 3]  # gTTS, pyttsx3, OpenAI, Edge-TTS
        
        for tts_opt in fallback_order:
            if tts_opt != current_tts and not tts_failed[tts_opt]:
                if TEST_MODE:
                    print(f"‚ö†Ô∏è Trying fallback TTS option {tts_opt}...")
                
                is_speaking = True
                success = speak_with_tts(text, tts_opt)
                is_speaking = False
                
                if success:
                    current_tts = tts_opt
                    if TEST_MODE:
                        print(f"‚úÖ Switched to TTS option {tts_opt}")
                    return True
                else:
                    tts_failed[tts_opt] = True
    
    if TEST_MODE:
        print("‚ùå All TTS options failed. Text displayed above.")
    return False

def cleanup_temp_files():
    """Clean up any leftover temporary files"""
    try:
        temp_dir = tempfile.gettempdir()
        for file in Path(temp_dir).glob("tmp*.wav"):
            try:
                os.remove(file)
            except:
                pass
        for file in Path(temp_dir).glob("tmp*.mp3"):
            try:
                os.remove(file)
            except:
                pass
    except:
        pass

# --- MAIN LOOP ---
try:
    while True:
        try:
            # Wait for wake word from background monitor
            if wake_word_detected:
                wake_word_detected = False  # Reset
                
                if TEST_MODE:
                    print("\nüü¢ Wake word detected!")
                
                # Stop any ongoing speech
                if is_speaking:
                    pygame.mixer.music.stop()
                    is_speaking = False
                    import time
                    time.sleep(0.2)  # Brief pause after interrupt
                
                interrupt_speech = False
                
                # Record and process command
                audio_file = record_audio()
                
                if audio_file:
                    command = transcribe_audio(audio_file)
                    
                    if command and len(command) > 2:
                        if TEST_MODE:
                            print(f"üó£Ô∏è You said: {command}")
                        else:
                            print(f"\nYou: {command}")
                        
                        response = ask_ai(command)
                        
                        if TEST_MODE:
                            print("üîä Preparing to speak...")
                        
                        interrupt_speech = False
                        speak(response)
                        
                        if TEST_MODE:
                            with history_lock:
                                if len(conversation_history) > 0:
                                    print(f"üí≠ Conversation memory: {len(conversation_history)} exchanges")
                        
                        # Clean up audio file
                        try:
                            os.remove(audio_file)
                        except:
                            pass
                    else:
                        speak("I didn't catch that. Could you repeat?")
                else:
                    speak("I had trouble recording. Please try again.")
                
                if TEST_MODE:
                    print("\nüéôÔ∏è Ready for next command...")
            
            # Small sleep to avoid CPU spinning
            import time
            time.sleep(0.05)
                
        except IOError:
            continue
            
except KeyboardInterrupt:
    print("\n\nüõë Shutting down Arthur...")
finally:
    if stream:
        stream.stop_stream()
        stream.close()
    pa.terminate()
    porcupine.delete()
    pygame.mixer.quit()
    cleanup_temp_files()
    print("üëã Goodbye!")